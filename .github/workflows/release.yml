name: Build and Release Blender Add-on

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set Up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: pip install tomli tomli-w

      - name: Extract Version from Tag or Input
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Use version from workflow_dispatch input
            TAG_NAME="${{ github.event.inputs.version }}"
          else
            # Use version from tag
            TAG_NAME="${{ github.ref_name }}"
          fi
          # Remove 'v' prefix if present (e.g., v1.0.5 -> 1.0.5)
          VERSION="${TAG_NAME#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION from tag/input: $TAG_NAME"

      - name: Validate Version Matches Tag
        id: validate
        run: |
          python << 'EOF'
          import tomli
          
          TAG_VERSION = "${{ steps.version.outputs.version }}"
          
          # Read current manifest version
          with open('blender_manifest.toml', 'rb') as f:
              manifest = tomli.load(f)
          
          MANIFEST_VERSION = manifest.get('version', '')
          
          if MANIFEST_VERSION != TAG_VERSION:
              print("⚠️  Version mismatch detected!")
              print(f"   Tag/Input version: {TAG_VERSION}")
              print(f"   Manifest version:   {MANIFEST_VERSION}")
              print("\n   The workflow will update blender_manifest.toml locally for the build")
              print("   and will also commit+push the bumped manifest back to the default branch.")
              needs_bump = "true"
          else:
              print(f"✅ Version matches: {TAG_VERSION}")
              needs_bump = "false"

          # Emit an output for later steps
          with open("${GITHUB_OUTPUT}", "a", encoding="utf-8") as f:
              f.write(f"needs_bump={needs_bump}\n")
          EOF

      - name: Update Version in Manifest (for build)
        run: |
          python << 'EOF'
          import tomli
          import tomli_w
          
          VERSION = "${{ steps.version.outputs.version }}"
          
          # Read manifest
          with open('blender_manifest.toml', 'rb') as f:
              manifest = tomli.load(f)
          
          # Update version
          old_version = manifest.get('version', 'unknown')
          manifest['version'] = VERSION
          
          # Write back
          with open('blender_manifest.toml', 'wb') as f:
              tomli_w.dump(manifest, f)
          
          print(f"Updated version from {old_version} to {VERSION} in blender_manifest.toml")
          EOF

      - name: Build Blender Add-on from Manifest
        id: build
        run: |
          python << 'EOF'
          import tomli
          import zipfile
          import os
          import fnmatch
          
          # Read manifest
          with open('blender_manifest.toml', 'rb') as f:
              manifest = tomli.load(f)
          
          addon_id = manifest['id']
          version = manifest['version']
          build_config = manifest.get('build', {})
          paths = build_config.get('paths', [])
          exclude_patterns = build_config.get('paths_exclude_pattern', [])
          
          # Create dist directory
          os.makedirs('dist', exist_ok=True)
          
          def should_exclude(rel_path):
              """Check if file should be excluded based on patterns."""
              for pattern in exclude_patterns:
                  if pattern.endswith('/'):
                      # Directory pattern - check if path starts with or contains it
                      pattern_dir = pattern.rstrip('/')
                      if rel_path.startswith(pattern_dir + '/') or rel_path == pattern_dir:
                          return True
                      # Check if any part of the path matches
                      path_parts = rel_path.split('/')
                      if pattern_dir in path_parts:
                          return True
                  else:
                      # File pattern - use fnmatch
                      if fnmatch.fnmatch(rel_path, pattern) or fnmatch.fnmatch(os.path.basename(rel_path), pattern):
                          return True
              return False
          
          # Create ZIP file
          zip_name = f'dist/{addon_id}-{version}.zip'
          with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:
              # Add all paths from manifest
              for path in paths:
                  path_clean = path.rstrip('/')
                  
                  if should_exclude(path_clean):
                      continue
                  
                  if os.path.isdir(path_clean):
                      # Add directory recursively
                      for root, dirs, files in os.walk(path_clean):
                          # Filter out excluded directories during walk
                          dirs[:] = [d for d in dirs if not should_exclude(os.path.join(root, d))]
                          
                          for file in files:
                              file_path = os.path.join(root, file)
                              rel_path = os.path.relpath(file_path, '.')
                              
                              if not should_exclude(rel_path):
                                  arcname = os.path.join(addon_id, rel_path)
                                  zipf.write(file_path, arcname)
                  elif os.path.isfile(path_clean):
                      # Add single file
                      if not should_exclude(path_clean):
                          arcname = os.path.join(addon_id, path_clean)
                          zipf.write(path_clean, arcname)
              
              # Always include the manifest file
              zipf.write('blender_manifest.toml', f'{addon_id}/blender_manifest.toml')
          
          # Write outputs for GitHub Actions
          output_file = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
          with open(output_file, 'a') as f:
            f.write(f"version={version}\n")
            f.write(f"asset_path={zip_name}\n")
            f.write(f"asset_name={os.path.basename(zip_name)}\n")
          print(f"Built {zip_name} with version {version}")
          EOF

      - name: Commit & Push Manifest Version Bump to Default Branch
        if: steps.validate.outputs.needs_bump == 'true'
        env:
          VERSION: ${{ steps.version.outputs.version }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          echo "Default branch: ${DEFAULT_BRANCH}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # We are checked out at a tag (detached HEAD). Update the default branch instead.
          git fetch origin "${DEFAULT_BRANCH}"
          git checkout "${DEFAULT_BRANCH}"

          python << 'EOF'
          import tomli
          import tomli_w
          import os

          version = os.environ["VERSION"]
          with open("blender_manifest.toml", "rb") as f:
              manifest = tomli.load(f)
          manifest["version"] = version
          with open("blender_manifest.toml", "wb") as f:
              tomli_w.dump(manifest, f)
          EOF

          git add blender_manifest.toml
          if git diff --cached --quiet; then
            echo "No manifest change to commit (already bumped on default branch)."
            exit 0
          fi

          git commit -m "Bump version to ${VERSION}"
          git push origin "${DEFAULT_BRANCH}"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.build.outputs.asset_path }}
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body: |
            ## Chord Song ${{ steps.build.outputs.version }}
            
            Blender add-on release built from tag ${{ github.ref_name }}.
            
            ### Installation
            1. Download `${{ steps.build.outputs.asset_name }}`
            2. In Blender, go to Edit > Preferences > Get Extensions
            3. Click "Install from Disk..." and select the ZIP file
            4. Enable the add-on
            
            ### Changes
            See the [changelog](https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.ref_name }}) for details.
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
